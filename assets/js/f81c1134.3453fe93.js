"use strict";(self.webpackChunkstefanicjuraj_github_io=self.webpackChunkstefanicjuraj_github_io||[]).push([[8130],{7735:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"benchmarking-docusaurus-openapi-plugin","metadata":{"permalink":"/blog/benchmarking-docusaurus-openapi-plugin","source":"@site/blog/15-08-2025.md","title":"Benchmarking Docusaurus OpenAPI Plugins","description":"When maintaining developer documentation with tens, hundreds, or even thousands of API endpoints, performance becomes critical. To better understand how different OpenAPI plugins for Docusaurus handle large and small documentation sets, I ran a series of benchmarks comparing their ease of integration, build times, client-side performance, and rendering behavior.","date":"2025-12-15T23:20:37.000Z","tags":[{"inline":true,"label":"docusaurus","permalink":"/blog/tags/docusaurus"}],"readingTime":3.995,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"Benchmarking Docusaurus OpenAPI Plugins","slug":"benchmarking-docusaurus-openapi-plugin","tags":["docusaurus"]},"unlisted":false,"nextItem":{"title":"The Cost of Not Opening Your Editor","permalink":"/blog/the-cost-of-not-opening-your-editor"}},"content":"When maintaining developer documentation with tens, hundreds, or even thousands of API endpoints, performance becomes critical. To better understand how different OpenAPI plugins for Docusaurus handle large and small documentation sets, I ran a series of benchmarks comparing their ease of integration, build times, client-side performance, and rendering behavior.\\n\\n\x3c!-- truncate --\x3e\\n\\nBenchmarking plugins under these different conditions helps identify which ones maintain performance at scale. It helps spot potential bottlenecks early and choose a plugin that will remain reliable as the content expands.\\n\\n## Plugins\\n\\n### [redocusaurus](https://github.com/rohit-gohri/redocusaurus)\\n\\nRedocusaurus is a preset for Docusaurus to help you integrate OpenAPI documentation via Redoc.\\n\\nRedocusaurus delivered consistent build performance across all documentation sizes, handling larger sets without a steep drop in speed. Its integration process was straightforward, requiring minimal adjustments to fit into an existing Docusaurus setup. While initial page load performance could be improved, the plugin\u2019s balance of stability, reasonable build times, and ease of configuration makes it a practical option for teams seeking reliable OpenAPI integration without extensive setup overhead.\\n\\n### [openapi-docs](https://github.com/PaloAltoNetworks/docusaurus-openapi-docs)\\n\\nThe docusaurus-plugin-openapi-docs package extends the Docusaurus CLI with commands for generating MDX using the OpenAPI specification as the source. The resulting MDX is fully compatible with plugin-content-docs and can be used to render beautiful reference API docs when combined with the docusaurus-theme-openapi-docs theme.\\n\\nOpenapi-docs offered strong compatibility with Docusaurus and provided extensive integration capabilities, making it well suited for complex documentation projects with advanced requirements. However, it recorded the slowest build times in this comparison, particularly with large documentation sets. This trade-off suggests that it is best suited for projects where rich feature support and flexibility are more important than build speed.\\n\\n### [scalar@docusaurus](https://github.com/scalar/scalar/tree/main/integrations/docusaurus)\\n\\nScalar achieved the fastest build times in all tested scenarios, maintaining quick performance even with large documentation sets. Integration was straightforward, and the plugin produced clean, usable API documentation without requiring much additional configuration. Its performance advantage makes it a strong choice for projects where short iteration cycles and rapid rebuilds are a priority, though it offers fewer built-in customization options compared to more feature-heavy alternatives.\\n\\n## Documentation sets\\n\\n- **Small set**: 10 API endpoints\\n- **Medium set**: 100 API endpoints\\n- **Large set**: 1000 API endpoints\\n\\n## Environment\\n\\n- **Hardware**: MacBook Pro (Apple M1 Pro, 32 GB RAM)\\n- **Node.js**: v20.12.2\\n- **Docusaurus**: v3.3.2, @docusaurus/faster\\n- **Benchmark method**: Measured wall-clock time using the shell `time` command.\\n  - npm builds: `time npm run build`\\n  - Deno builds: `time deno task build`\\n\\n## Metrics\\n\\nThese are the metrics I used to evaluate the plugins. They are not necessarily mutually exclusive, but I tried to keep them as independent as possible.\\n\\n| Metric                      | Description                                                                                            |\\n| :-------------------------- | :----------------------------------------------------------------------------------------------------- |\\n| **Build time** (small set)  | Time to generate the full static site from source using a minimal documentation set, no cache present. |\\n| **Build time** (medium set) | Time to rebuild the site with a minimal documentation set using cached files.                          |\\n| **Build time** (large set)  | Time to generate the full static site from source using a large documentation set, no cache present.   |\\n| **Integration**             | Number of steps and adjustments needed to make the plugin work with an existing Docusaurus project.    |\\n| **Loading**                 | Time for the first page load after build.                                                              |\\n| **Configuration**           | Whether extra setup was necessary beyond basic installation (e.g. theme, customizations, etc.).        |\\n| **UX / UI**                 | How the plugin looks and feels in terms of design, layout, and usability.                              |\\n\\n## Results\\n\\n| Plugin                                                                                  | Build time (S) | Build time (M) | Build time (L) | Integration | Loading | Configuration | UX / UI |\\n| :-------------------------------------------------------------------------------------- | :------------- | :------------- | :------------- | :---------- | :-----: | :------------ | :------ |\\n| [redocusaurus](https://github.com/rohit-gohri/redocusaurus)                             | 2m 15s         | 3m 15s         | 5m 30s         | < 5         |   \u274c    | \u2705            | 6/10    |\\n| [openapi-docs](https://github.com/PaloAltoNetworks/docusaurus-openapi-docs)             | 5m 10s         | 8m 30s         | 15m 30s        | > 20        |   \u2705    | \u2705            | 8/10    |\\n| [scalar@docusaurus](https://github.com/scalar/scalar/tree/main/integrations/docusaurus) | 1m 10s         | 2m 15s         | 4m 30s         | < 5         |   \u274c    | \u274c            | 8/10    |\\n\\nAcross the tested plugins, build performance varies significantly depending on the size of the documentation set. Scalar delivers the fastest builds overall, making it a strong choice for projects where short iteration cycles are a priority. Redocusaurus offered a balance between speed and ease of setup, performing reliably with both small and large sets. Openapi-docs produced the slowest builds in this comparison but provided comprehensive integration capabilities and strong compatibility with Docusaurus features. The results suggest that the optimal choice depends on whether build speed, integration flexibility, or feature completeness is the primary requirement.\\n\\nThese benchmarks aim to provide practical guidance for technical writers, developers, and documentation teams evaluating Docusaurus OpenAPI plugins."},{"id":"the-cost-of-not-opening-your-editor","metadata":{"permalink":"/blog/the-cost-of-not-opening-your-editor","source":"@site/blog/05-05-2025.md","title":"The Cost of Not Opening Your Editor","description":"Lately, I have been creating my own smaller applications to solve specific problems, instead of paying for products that either overcharge or overcomplicate simple tasks.","date":"2025-12-15T23:20:24.000Z","tags":[],"readingTime":0.86,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"The Cost of Not Opening Your Editor","slug":"the-cost-of-not-opening-your-editor","sidebar_position":1},"unlisted":false,"prevItem":{"title":"Benchmarking Docusaurus OpenAPI Plugins","permalink":"/blog/benchmarking-docusaurus-openapi-plugin"},"nextItem":{"title":"Vibe Coding","permalink":"/blog/vibe-coding"}},"content":"Lately, I have been creating my own smaller applications to solve specific problems, instead of paying for products that either overcharge or overcomplicate simple tasks.\\n\\n\x3c!-- truncate --\x3e\\n\\nWith the recent development of AI tools, and a lot of people vibe coding quick applications, there are now many tiny tools with insane pricing, wrapped in subscriptions, hidden data flows, and limited transparency often doing one or two things you could build yourself in a few hours.\\n\\nWhenever possible, I try to follow the [file-over-app](https://stephango.com/file-over-app) philosophy: using a file that you own, store locally, and version yourself, instead of relying on external applications to manage it for you.\\n\\nIt\'s not just about saving money, it\'s about knowing exactly where your data goes, how your logic works, and avoiding adding another unknown dependency into your workflow.\\n\\nI read this on a blog post somewhere and it resonated with me:\\n\\n> \\"At some point, you\'re not paying for the product, you\'re paying to not open your code editor.\\"\\n\\n---\\n\\n<iframe src=\\"https://stephango.com/file-over-app\\" width=\\"100%\\" height=\\"600\\" frameborder=\\"0\\" ></iframe>"},{"id":"vibe-coding","metadata":{"permalink":"/blog/vibe-coding","source":"@site/blog/25-04-2025.md","title":"Vibe Coding","description":"Vibe coding is gradually moving from weekend experiments to actual product development workflows. The more I see it used in real projects, the more obvious it becomes how rarely security is part of that conversation.","date":"2025-12-15T23:20:12.000Z","tags":[],"readingTime":1.235,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"Vibe Coding","slug":"vibe-coding","sidebar_position":1},"unlisted":false,"prevItem":{"title":"The Cost of Not Opening Your Editor","permalink":"/blog/the-cost-of-not-opening-your-editor"},"nextItem":{"title":"em dash (\u2014), en dash (\u2013), or hyphen (-)","permalink":"/blog/em-dash-en-dash-or-hyphen"}},"content":"Vibe coding is gradually moving from weekend experiments to actual product development workflows. The more I see it used in real projects, the more obvious it becomes how rarely security is part of that conversation.\\n\\n\x3c!-- truncate --\x3e\\n\\nI\u2019ve been vibe coding to develop parts of my projects, not the whole thing, but enough to see where it helps and where it introduces risk.\\n\\nWhen you are in a flow where you are just asking for what you need (\u201cadd auth\u201d, \u201cfix this error\u201d, \u201cgenerate backend\u201d), it\u2019s easy to skip over the things that aren\u2019t visible. You\u2019re not thinking about how user input is sanitized, whether error handling is robust, or if sensitive routes are protected. You don\u2019t always check how database queries are constructed, whether default settings expose ports or data, or what access controls are missing.\\n\\nThese are not things the LLM models will always surface, and they\u2019re not things you\u2019ll catch if you\u2019re focused only on the immediate output. You get working code, but the deeper assumptions behind it \u2014 how it handles edge cases, what it trusts by default, or what gets logged can go unnoticed.\\n\\nThe issue isn\u2019t that AI-generated code is always insecure. It\u2019s that vibe coding workflows make it harder to notice when something is insecure. The more abstracted the process becomes, the more invisible those decisions are.\\n\\n<iframe\\n    width=\\"80%\\"\\n    height=\\"500\\"\\n    src=\\"https://www.reversinglabs.com/blog/vibe-coding-what-autonomous-code-means-for-appsec\\"\\n    title=\\"Vibe coding: What automating development means for AppSec\\"\\n    frameborder=\\"0\\"\\n    allow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\"\\n    allowfullscreen>\\n</iframe>"},{"id":"em-dash-en-dash-or-hyphen","metadata":{"permalink":"/blog/em-dash-en-dash-or-hyphen","source":"@site/blog/15-04-2025.md","title":"em dash (\u2014), en dash (\u2013), or hyphen (-)","description":"Apparently, using an em dash (\u2014), en dash (\u2013), or hyphen (-) in a text is now used to classify it as AI-written.","date":"2025-12-15T23:20:03.000Z","tags":[],"readingTime":0.73,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"em dash (\u2014), en dash (\u2013), or hyphen (-)","slug":"em-dash-en-dash-or-hyphen","sidebar_position":1},"unlisted":false,"prevItem":{"title":"Vibe Coding","permalink":"/blog/vibe-coding"},"nextItem":{"title":"Modern Web Applications","permalink":"/blog/modern-web-applications"}},"content":"Apparently, using an em dash (\u2014), en dash (\u2013), or hyphen (-) in a text is now used to classify it as AI-written.\\n\\n\x3c!-- truncate --\x3e\\n\\nI\u2019ve been using em dashes for a long time \u2014 almost in every post I write. They help structure a sentence without breaking the flow by adding rhythm, clarity, and precision when used intentionally. Sometimes a comma feels too weak, and a period too final.\\n\\nAnd although I agree that many AI-generated texts tend to overuse or misuse punctuation, it feels odd to instantly flag something so natural and useful as artificial. Writing styles vary. People think and write in different rhythms, and punctuation helps reflect that.\\n\\n> \\"Language doesn\u2019t exist to oppress us \u2014 it exists to promote the clarity of expression.\\"\\n\\n<iframe\\n    width=\\"100%\\"\\n    height=\\"500\\"\\n    src=\\"https://www.youtube.com/embed/Bd8r7LUiUJA\\"\\n    title=\\"YouTube video player\\"\\n    frameborder=\\"0\\"\\n    allow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\"\\n    allowfullscreen>\\n</iframe>"},{"id":"modern-web-applications","metadata":{"permalink":"/blog/modern-web-applications","source":"@site/blog/10-04-2025.md","title":"Modern Web Applications","description":"As someone who just recently started being involved in creating and tinkering with a lot of modern full stack web applications, I found this post by Andrej Karpathy spot-on.","date":"2025-12-15T23:19:46.000Z","tags":[],"readingTime":1.75,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"Modern Web Applications","slug":"modern-web-applications","sidebar_position":1},"unlisted":false,"prevItem":{"title":"em dash (\u2014), en dash (\u2013), or hyphen (-)","permalink":"/blog/em-dash-en-dash-or-hyphen"}},"content":"As someone who just recently started being involved in creating and tinkering with a lot of modern full stack web applications, I found this post by Andrej Karpathy spot-on.\\n\\n\x3c!-- truncate --\x3e\\n\\n<img src=\\"/img/web-apps-andrej-karpathy.jpeg\\" width=\\"70%\\" alt=\\"Reality of building modern web apps\\" />\\n\\nWhen I committed fully into this, I was expecting (hoping) there to be an \\"out of the box\\" solution that would unite most of the tech stack needed to build a full stack web application: frontend, backend, database, authentication, deployment, CI/CD, hosting, analytics, monitoring, etc. Something opinionated enough to work together smoothly, but flexible enough not to get in the way. Instead, what you find is a loosely connected collection of services, libraries, and platforms, each solving a specific part, but requiring you to stitch everything together yourself.\\n\\nWhat stands out the most is that once you start developing a full stack web application, the focus quickly shifts from coding to orchestrating. You\u2019re suddenly not writing code anymore, but managing infrastructure, configurations, connections, and integrating services that don\u2019t always work well together. Every small decision comes with a cascade of tradeoffs, options, and moving parts.\\n\\nTo add on, for most of these services you need to create separate accounts, connect them manually, read through the documentation, and maintain each integration individually. It\u2019s rarely a one-time setup. APIs change, tokens expire, limits get hit, or logs need to be tracked down across dashboards. It\'s not just development anymore, it\'s constant context switching between platforms, each with its own UI, terminology, and behavior.\\n\\nOne small deviation from a \u201cgetting started\u201d guide, and you\u2019re deep in the internals of something you didn\u2019t plan to learn that day. Most of the time, the issues aren\u2019t even bugs, they\u2019re misalignments between tools that weren\u2019t built to work together by default.\\n\\nNone of these pieces are especially difficult in isolation. But connecting them, handling environment configuration, dealing with production errors, and maintaining reliability across updates takes more time and energy than expected.\\n\\nWhoever solves this for both humans and AIs will unlock serious momentum.\\n\\n<img src=\\"/img/web-apps-technologies.png\\" width=\\"70%\\" alt=\\"Reality of building modern web apps\\" />"}]}}')}}]);